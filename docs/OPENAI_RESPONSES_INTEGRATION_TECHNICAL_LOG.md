# OpenAI Responses API Integration - Technical Investigation Log

**Date**: 2025-01-20
**Status**: ✅ FIXED - Working with prompt-based tools
**Engineer**: Session Analysis

---

## Executive Summary

**Problems Found**:
1. Architectural mismatch (stateful function calling vs stateless XML tools)
2. Nested response structure (`text` as array instead of string)
3. Empty responses after 5-6 turns (stateful chaining overflow)

**Solutions**:
1. Disabled API function calling, use prompt-based tools
2. Extract XML from `text[0].text` nested structure
3. Convert all messages to plain text format
4. Detect empty responses, reset stateful chaining, provide clear error

**Result**: ✅ Functional integration with automatic recovery from empty responses

---

## Problem Summary

Integration of OpenAI Responses API with Cline failing due to:
1. **Architectural incompatibility**: Cline's stateless XML tool system vs OpenAI's stateful function calling API
2. **Response format mismatch**: API returns nested array structure not properly handled

---

## Error Timeline & Root Causes

### Error 1: `e.output is not iterable`

**Symptom**: API request fails immediately
**Location**: `openai-responses-provider.ts:208`
**Root Cause**: Missing response validation before iteration

```typescript
// BEFORE (BROKEN)
for (const item of response.output) { ... }

// AFTER (FIXED)
if (!response.output || !Array.isArray(response.output)) {
    throw new Error(`Invalid response structure: expected 'output' array, got ${typeof response.output}`);
}
```

**Fix**: Added response structure validation in `translateResponseFromResponsesAPI()`

---

### Error 2: `No tool output found for function call call_v3lBFnXWCFUpBE9rS0vuw6BR`

**Symptom**: First API call succeeds, tool executes, second call fails
**Root Cause**: **CRITICAL ARCHITECTURAL MISMATCH**

#### The Call ID Mismatch Problem

```
Flow:
1. Handler sends tools → API creates call_id: "abc123"
2. API returns function_call → We convert to XML
3. Cline parses XML, executes tool
4. Cline returns result with NEW id: "xyz789"  ← GENERATED BY CLINE
5. API expects call_id: "abc123" but receives "xyz789"
6. ERROR: call_id mismatch
```

**Why This Happens**:
- OpenAI function calling is **stateful** (requires call_id tracking)
- Cline's XML tools are **stateless** (no IDs, just XML parsing)
- When converting `function_call` → XML → `tool_result`, call_id is lost

**Original Broken Code**:
```typescript
// openai-responses-provider.ts:184-193
for (const toolResult of toolResultBlocks) {
    inputMessages.push({
        type: 'function_call_output',
        call_id: toolResult.tool_use_id,  // ← Cline's ID, not API's ID
        output: outputContent
    });
}
```

---

### Error 3: `[错误] 您在上一个回应中没有使用工具！`

**Symptom**: Model outputs conversational text instead of XML tool calls
**Root Cause**: Model not instructed to use prompt-based tools

**Why**: After disabling API function calling, model doesn't know it should output XML in text format.

---

### Error 4: `u.text.substring is not a function`

**Symptom**: Crash when logging response
**Location**: `openai-responses.ts:309`
**Root Cause**: `block.text` is not a string (possibly object or array)

```typescript
// BEFORE (BROKEN)
console.log(`Text preview: ${block.text.substring(0, 200)}...`)

// AFTER (FIXED)
const textContent = typeof block.text === 'string'
    ? block.text
    : JSON.stringify(block.text)
```

---

### Error 5: Empty Response After 5-6 Turns

**Symptom**: "意外的 API 响应：语言模型没有提供任何助手消息"
**When**: After 5-6 successful tool calls with stateful chaining
**Root Cause**: Context window overflow or stateful chaining corruption

#### Console Logs Pattern

```
Request 1: messages=1  → ✅ Works
Request 2: messages=3  + previous_response_id → ✅ Works
Request 3: messages=5  + previous_response_id → ✅ Works
Request 4: messages=7  + previous_response_id → ✅ Works
Request 5: messages=9  + previous_response_id → ✅ Works
Request 6: messages=11 + previous_response_id → ❌ EMPTY
```

#### API Response

```javascript
Block 0: {"type":"text","text":[{"type":"output_text","text":""}]}
Extracted text:
// ↑ EMPTY STRING!
```

#### Root Causes

1. **Context window overflow**: Conversation + context exceeds model limit
2. **Stateful chain corruption**: Previous response ID references invalid state
3. **Model safety filter**: Content triggered safety mechanism
4. **API error**: Server-side issue returning empty without error code

#### Solution Implemented

Added empty response detection and automatic recovery:

```typescript
// 12.5. Check for empty output
if (response.output.length === 0) {
    throw new Error(`Empty output from API. Previous response ID: ${this.lastResponseId}`);
}

// 13.5. Validate translated content
if (translated.content.length === 0 ||
    (translated.content.length === 1 && !translated.content[0].text)) {

    // Reset stateful chaining
    this.lastResponseId = undefined;

    throw new Error(`Empty response from model. Stateful chaining has been reset. Please try again.`);
}
```

#### User Impact

**Before Fix**:
- Silent failure after 5-6 turns
- Generic error message
- Conversation stuck, manual restart needed

**After Fix**:
- Clear error message explaining cause
- Automatic stateful chaining reset
- User can retry immediately
- Error logged with context for debugging

---

## Architectural Analysis

### Cline's Tool System

```
Design: Stateless, Prompt-Based
Format: XML tags in text

Example:
<read_file>
<path>README.md</path>
</read_file>

Parser: parseAssistantMessageV2() extracts tools from text
Execution: Tools run, results return as text
```

### OpenAI Responses API

```
Design: Stateful, API-Based
Format: JSON function_call objects

Example:
{
  "type": "function_call",
  "call_id": "call_abc123",
  "name": "read_file",
  "arguments": "{\"path\":\"README.md\"}"
}

Response Required:
{
  "type": "function_call_output",
  "call_id": "call_abc123",  // MUST MATCH
  "output": "..."
}
```

### The Fundamental Incompatibility

| Aspect | Cline | OpenAI Responses API |
|--------|-------|---------------------|
| State | Stateless | Stateful |
| Tool Format | XML in text | JSON function_call |
| ID Tracking | None | Required (call_id) |
| Tool Results | Plain text | function_call_output with call_id |

**Conclusion**: Cannot use API function calling with Cline's architecture.

---

## Solution: Prompt-Based Tools Only

### Strategy

1. **Disable API function calling** - Don't send `tools` parameter
2. **Convert all to text** - Tool results as plain text, not function_call_output
3. **Let model learn from prompt** - System prompt describes tool XML format
4. **Model outputs XML** - Model generates `<read_file>...</read_file>` in text

### Implementation

#### File: `openai-responses.ts`

**Created `convertAnthropicToTextOnly()`**:
```typescript
private convertAnthropicToTextOnly(messages: Anthropic.Messages.MessageParam[]): any[] {
    return messages.map(msg => {
        let textContent = ''

        for (const block of msg.content) {
            if (block.type === 'text') {
                textContent += block.text + '\n'
            } else if (block.type === 'tool_result') {
                // CRITICAL: Convert to plain text, NOT function_call_output
                const resultContent = typeof block.content === 'string'
                    ? block.content
                    : JSON.stringify(block.content)
                textContent += resultContent + '\n'
            }
        }

        return { role: msg.role, content: textContent.trim() }
    })
}
```

**Modified `createMessage()`**:
```typescript
const response = await provider.createMessage({
    system: systemPrompt,
    messages: miniClaudeMessages,
    tools: undefined,  // ← KEY: No API function calling
    maxTokens: this.options.maxOutputTokens,
    temperature: this.options.temperature
})
```

#### File: `openai-responses-provider.ts`

**Enhanced error handling**:
```typescript
// Check HTTP status BEFORE parsing JSON
if (!initialResponse.ok) {
    const errorText = await initialResponse.text();
    // Parse error, log details
    throw new Error(`OpenAI Responses API error: ${errorMessage}`);
}

// Validate response structure BEFORE iteration
if (!response.output || !Array.isArray(response.output)) {
    throw new Error(`Invalid response structure: expected 'output' array...`);
}
```

---

## Current Status: Type Mismatch Issue

### Problem
```javascript
TypeError: u.text.substring is not a function
```

### Analysis

Log shows:
```
Block 0: type=text
```

But `block.text` is not a string. OpenAI Responses API may return text in different structure than expected.

### Implemented Fix

Added type checking and conversion:
```typescript
for (const block of response.content) {
    if (block.type === 'text') {
        const textContent = typeof block.text === 'string'
            ? block.text
            : JSON.stringify(block.text)  // Convert if not string

        yield { type: "text", text: textContent }
    }
}
```

### Next Investigation Required

Check actual structure of `block.text` from API response to understand format.

---

## Files Modified

### Primary Changes

1. **`src/api/providers/openai-responses.ts`**
   - Created `convertAnthropicToTextOnly()` - converts all to text
   - Disabled API function calling (`tools: undefined`)
   - Added type checking for response blocks
   - Added debug logging

2. **`src/services/mini-claude/providers/openai-responses-provider.ts`**
   - Enhanced HTTP error handling with status checks
   - Added response structure validation
   - Improved error messages with full response logging
   - Added request/response debug logs

### Created Files

3. **`src/api/providers/openai-responses-tools.ts`**
   - Tool definitions (currently unused, can be deleted)
   - Created for API function calling approach (abandoned)

---

## Key Learnings

### 1. Architecture Matters
**Don't force stateful API onto stateless architecture**. Cline's XML tool system is stateless by design. Attempting to use OpenAI's stateful function calling creates fundamental incompatibility.

### 2. call_id Tracking Problem
When converting between API formats, IDs don't persist:
```
API call_id → XML (ID lost) → Cline execution → New ID → Mismatch error
```

### 3. Prompt-Based vs API-Based Tools
- **Prompt-based**: Model learns from examples, outputs structured text
- **API-based**: Model uses predefined functions with ID tracking

Cline uses prompt-based. Must match this approach.

### 4. Response Format Assumptions
Never assume API response structure matches expectations. Always validate:
- Check HTTP status
- Validate JSON structure
- Type check fields before using
- Handle both string and non-string responses

---

## Debugging Strategy Used

1. **Add comprehensive logging** at request/response boundaries
2. **Check HTTP status** before parsing JSON
3. **Validate structure** before iteration
4. **Type check** before string operations
5. **Use JSON.stringify()** for debug output to see actual structure

---

## ✅ FINAL FIX IMPLEMENTED

### Discovery: Nested Array Structure

Console logs revealed the actual API response format:
```javascript
Block 0: {
  "type": "text",
  "text": [  // ← ARRAY, not string!
    {
      "type": "output_text",
      "annotations": [],
      "logprobs": [],
      "text": "<read_file>\n<path>src/core/controller/index.ts</path>\n</read_file>"
    }
  ]
}
```

### Root Cause
- OpenAI Responses API returns `block.text` as **array** of `output_text` objects
- Previous code: `JSON.stringify(block.text)` → `"[{\"type\":\"output_text\"...}]"`
- Cline received JSON string instead of XML
- XML parser couldn't find `<read_file>` inside JSON string
- Error: "You didn't use tools!"
- Model uses `<attempt_completion>` thinking done
- User never sees output

### Solution Implemented

Extract actual text from nested structure in `openai-responses.ts`:
```typescript
const rawText: any = block.text

if (typeof rawText === 'string') {
    textContent = rawText
} else if (Array.isArray(rawText)) {
    // Extract from output_text array
    for (const item of rawText) {
        if (item?.type === 'output_text' && item?.text) {
            textContent += item.text  // ← Get actual XML
        }
    }
} else {
    textContent = JSON.stringify(rawText)
}
```

### Results

**Now Working**:
1. ✅ Model outputs correct XML tools
2. ✅ XML extracted from `text[0].text`
3. ✅ Cline receives clean XML
4. ✅ Tools parse and execute
5. ✅ Stateful chaining active (`previous_response_id`)
6. ✅ Tasks complete successfully
7. ✅ Output displayed to user

**Confirmed via Logs**:
- Multiple tool calls executed: `read_file`, `list_files`
- Stateful chaining working across requests
- Model following XML format perfectly
- Checkpoints created successfully

---

## Technical Debt

1. **`openai-responses-tools.ts`** - Unused file, can be deleted
2. **Debug logs** - Should be removed or made conditional for production
3. **Error messages** - Still mixing English/Chinese
4. **Type definitions** - Response structure not properly typed

---

## Next Steps for Complete Fix

1. **Get actual API response structure** via console logs
2. **Verify text format** - string, object, or array?
3. **Test with simple prompt** to see XML output
4. **Validate XML parsing** works with actual model output
5. **Remove debug logs** after confirming fix
6. **Add proper TypeScript types** for API responses

---

## Code Snippets Reference

### Correct Way to Handle Responses API with Cline

```typescript
// 1. Convert messages to text-only (no function_call_output)
const miniClaudeMessages = this.convertAnthropicToTextOnly(messages)

// 2. Don't send tools parameter
const response = await provider.createMessage({
    system: systemPrompt,  // Contains tool descriptions
    messages: miniClaudeMessages,
    tools: undefined,  // No API function calling
    ...
})

// 3. Handle text with type checking
for (const block of response.content) {
    if (block.type === 'text') {
        const text = typeof block.text === 'string'
            ? block.text
            : JSON.stringify(block.text)
        yield { type: "text", text }
    }
}
```

### Error Handling Pattern

```typescript
// Check HTTP first
if (!response.ok) {
    const error = await response.text()
    throw new Error(`API error: ${error}`)
}

// Validate structure
const data = await response.json()
if (!data.output || !Array.isArray(data.output)) {
    throw new Error(`Invalid structure: ${JSON.stringify(data)}`)
}

// Type check fields
const text = typeof item.text === 'string'
    ? item.text
    : JSON.stringify(item.text)
```

---

## Conclusion

OpenAI Responses API integration requires **prompt-based tool approach**, not API function calling. Current blocker is understanding actual response text structure to properly convert and yield to Cline.

**Status**: Awaiting console logs to determine `block.text` format and proceed with final fix.
